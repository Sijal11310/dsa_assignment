# Sorting Algorithms Program – Function Explanation

This document explains the use of every function in the C program that carries out the generation of random numbers and their sorting through different sorting algorithms with comparison as well as swap counting.

## swap(int *x, int *y)

This function swaps two integer values using pointers. It accepts two integer addresses as its parameters. A temporary variable helps to keep one of the values during swapping. Every time this function is used, it increases the global swaps counter by one. Mostly, this function is applied in Bubble Sort and Selection Sort.

## selectionSort(int arr[], int size)`

This function uses the selection sort method. It keeps thinking of the list as two sections, one that has been arranged and one that has not. In each step, it finds the smallest item from the side that's not yet sorted. That minimum gets swapped with the first item of the unsorted section. The steps go on until all parts are in order. Every time items are checked against each other, add one to the comparison count, and for every real swap made add one to the swaps count.

### Time Complexity:

* Best Case: O(n²)
* Average Case: O(n²)
* Worst Case: O(n²)

## bubbleSort(int a[], int n)

This function will use the Bubble Sort approach to sort the provided array. It keeps on comparing adjacent elements and swapping them if in a wrong order till every element is at its correct position. The last element to move, after one complete pass, will always be the largest placed at its correct position at the end of the array. This process will continue repeating for the next reduced size of an unsorted array until it is fully sorted. Each and every comparison increments comparisons counter, and swaps increments swaps counter.

### Time Complexity:

* Best Case: O(n) (optimized version)
* Average Case: O(n²)
* Worst Case: O(n²)

## merge(int a[], int l, int m, int r)

It combines two sorted parts into one sorted array. The split is such that one part starts from index l to m, and the other starts from m+1 to r. Temporary arrays will be used here for storing elements of both these parts, and then comparison of elements from temporary arrays followed by copying back into the original array in a sorted order shall take place. Only comparisons shall occur in this function. No swaps happen here.

## mergeSort(int a[], int l, int r)͏‌

This function will use Merge Sort to perform sorting of the array. Merge sort is also a divide-and-conquer approach. The array breaks recursively into further smaller subarrays up to the point where each subarray contains just one element. They are merged back in sorted order using a merge() function. Counting is performed during comparison in merging as there are no swaps applicable here.

### Time Complexity:

* Best Case: O(n log n)
* Average Case: O(n log n)
* Worst Case: O(n log n)

## printArray(int a[], int n)

printArray(int a[], int n) will print all elements of the array by traversing through it and printing elements one after the other. It is used to display contents of the array before and after performing sort on it.

## main()

This is the driver function. It picks up the number of elements from user input and fills them up with random numbers between 1 and 1000 using the rand() function. It displays a menu where the user can select a sorting algorithm. According to the user’s choice, that particular sorting function gets called here. The array is printed before and after sorting along with the total comparisons and swaps made.

## Notes

- Merge Sort does not count swaps since it does not perform any swaps. Therefore, there will be nothing to update. 

- Global variables for comparison and swapping are used here so that the tally can be made on different sortings. 

- The random numbers are generated through the functions under stdlib.h

