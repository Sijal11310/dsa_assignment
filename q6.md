# Min and Max Heap Implementation

## Introduction

This program accepts an array from the user and converts it to a Min Heap as well as a Max Heap. Heaps are known to be tree-based data structures that fulfill the heap property. The construction of heaps is essential since they find massive applications in priority queues as well as many sorting algorithms like Heap Sort.

## Data Structure Used

The implementation takes the help of a linear array representation of a complete binary tree.

For an element stored at index i:

* Left Child index = 2i + 1
* Right Child index = 2i + 2
* Parent index = ⌊(i − 1) / 2⌋

This structure of the array permits an easy walk and manipulation of the heap organization.

## FUNCTIONS USED

### swap(int *a, int *b)

It receives for input the addresses of two variables and interchanges their values. A temporary variable is used in effecting the exchange. This function will be applied several times during the building up of both Min Heap and Max Heap structures.

### maxHeapify(int arr[], int n, int i)

Recursion that helps maintain the Max Heap property.

* **Logic:** It calculates the left and right child indices of node i to compare with them which among itself and its children has the largest value.
* **Action:** If any of the children has a value greater than the parent, swap the parent with its largest child.
* **Recursion:** After swapping, call recursively on the affected child node, so that the subtree continues to satisfy the Max Heap property.

### minHeapify(int arr[], int n, int i)

This function bubbles the element if it is not in its right place according to the Min Heap property.

* **Logic:** Calculate left and right children of node 'i' then compare which one has the smallest value among the parent and its children.
* **Action:** If the parent node is not the smallest then swap it with the smallest among its children.
* **Recursion:** Continue until the subtree with root at index i fits the Min Heap rules.

### buildMaxHeap(int arr[], int n)

Converts an unsorted array into a valid Max Heap.

* **Logic:** Begin heapification from the last non-leaf node to (n / 2) − 1 index.
* **Execution:** Loop backward from this index up to the root node at 0, calling maxHeapify() for each index. By the time the loop is done, the whole array will be a Max Heap.

### buildMinHeap(int arr[], int n)

Builds a Min Heap using the bottom-up approach.

* **Logic and Execution:** `for (int i = (n / 2) - 1; i = 0; i--) minHeapify(arr, n, i);` This is efficient in O(n) time; this is how heap construction is done.

### printArray(int arr[], int n)

Displays the elements of the heapified array in level-order traversal as they appear in the array representation of a heap.

### main()

The driver function.

* **Input:** User inputs the elements of the array.
* **Memory:** Uses `malloc` dynamic memory allocation to allocate space for two arrays: one for Max Heap and one for Min Heap.
* **Order of Execution:** buildMaxHeap() is called first to construct a Max Heap and results are printed. Then buildMinHeap() is called using a copy of the original array, and results of Min Heap are printed.

## SAMPLE OUTPUT

**Input Elements:** 12, 11, 13, 5, 6, 7

**Max Heap Result:** 13 11 12 5 6 7
**Min Heap Result:** 5 6 7 12 11 13
