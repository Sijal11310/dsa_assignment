# <p align="center">MIN AND MAX HEAP IMPLEMENTATION</p>

## <p align="center">INTRODUCTION</p>

The program takes an array as an input form the user and transform it into both **Min Heap** and **Max Heap**. Heaps are tree based data structures that satisfy the heap property. Making heaps is essential for priority queues and sorting algorithms. 

---

## <p align="center">DATA STRUCTURE USED</p>

The heap here is implemented using a **Linear Array** to represent a **Complete Binary Tree**.

For any element located at index $i$:  
**Left Child:** $2i + 1$  
**Right Child:** $2i + 2$  
**Parent:** $\lfloor (i - 1) / 2 \rfloor$



---

## <p align="center">FUNCTIONS USED</p>

### swap(int *a, int *b)

This function takes the adress of two variables a and b as an argument and swaps the variables value with each other. This function will be used multiple time while building a heap no matter the type of heap.

---

### maxHeapify(int arr[], int n, int i)

This is a recursive function used to maintain the **Max Heap** property. A Max Heap requires every parent node is greater than or equal to its children.

* **Logic:** The function identifies the left and right children of node $i$. It compares the parent with both children to find the **largest** of the three.

* **Action:** If a child's value is larger than the current node $i$, they are swapped.

* **Recursion:** After a swap, the function recursively calls itself on the affected subtree to ensure that the swap didn't violate the heap property.



---

### minHeapify(int arr[], int n, int i)

This function operates similarly to `maxHeapify` but maintains the **Min Heap** property i.e where every parent node must be smaller than or equal to its children.

* **Logic:** It calculates child indices and determines the **smallest** value among parent and its children.

* **Action:** If the parent is not the smallest, it swaps with the smallest child.

* **Recursion:** It continues to "sift down" the value until the subtree rooted at $i$ satisfies the Min Heap condition.



---

### buildMaxHeap(int arr[], int n)

This function converts an array into a valid Max Heap. 

* **Logic:** Instead of processing every node, it starts from the **last non-leaf node**  which is located at index $n/2 - 1$. 

* **Execution:** It loops backwards from this index up to the root (index 0), calling `maxHeapify` at each step. By the time it reaches the root, the entire array is guaranteed to satisfy the Max Heap property.

---

### buildMinHeap(int arr[], int n)

This function follows the same bottom-up construction logic as `buildMaxHeap`. It loops from $n/2 - 1$ down to 0, but calls `minHeapify` at each iteration. This approach is highly efficient, with a total time complexity of $O(n)$, making it the standard method for heap construction.

---

### printArray(int arr[], int n)

This function takes the array that is heapified as an argument and prints all the elements in tree(level wise).

---

### main()

The driver function of the program. It manages user interaction and memory:
1.  **Input:** Asks user to input data.
2.  **Memory:** Uses `malloc` to create two arrays (one for Max Heap and one for Min Heap).
3.  **Execution:** calls buildMaxHeap(arr, n) to Max Heapify the array and then print it and then calls
                      buildMinHeap(tempArr, n) to Min Heapify the array and print it .


---


# <p align="center">SAMPLE OUTPUT</p>

**Input Elements:** 12, 11, 13, 5, 6, 7

**Max Heap Result:** 13 11 12 5 6 7  
**Min Heap Result:** 5 6 7 12 11 13