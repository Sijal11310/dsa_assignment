# DIJKSTRA'S SHORTEST PATH ALGORITHM

## INTRODUCTION

It runs Dijkstra’s Algorithm to solve the Single-Source Shortest Path problem. A weighted graph and starting node are entered manually to this program, then, it returns the shortest distance from that source node to every other reachable vertex. It uses a greedy approach, hence ensuring optimal shortest paths.

## Data Structure Used

It gets implemented using an adjacency matrix and some helper arrays.

* **Adjacency Matrix (graph[V][V]):** This is a two-dimensional array in which graph[i][j] will return the weight of the edge between vertex i and vertex j. If it returns 0, then there is no direct connection between those vertices.

* **Distance Array (dist[V]):** This shall hold the current shortest distance from source to every other vertex.

* **Visited Array (visited[V]):** Works like a boolean because 0 means not visited, 1 means visited. This will help us track which have already been included in the tree of the shortest path.

## FUNCTIONS USED

### findMinDistance(int dist[], int visited[])

This function looks for the vertex with the smallest distance value that hasn't been visited yet.

* **How does it work:** It goes through the dist[] array and finds the minimum distance value among those vertices for which visited[] is 0.

* **Why does it work:** This function helps to maintain the greedy nature of the Dijkstra algorithm by picking the next closest unvisited vertex.

### dijkstra(int graph[V][V], int src)

This is where the core logic of Dijkstra’s shortest path algorithm sits.

* **Initialization:** Set all values in the dist[] array to a very large value (infinity). Set all vertices as unvisited. The distance of the source vertex to itself is 0.

* **Main Loop:** Repeat for V−1 times. In every iteration, pick the vertex with the minimum distance (as returned by findMinDistance) and mark it as visited.

* **Relaxation:** For all adjacent vertices of that selected vertex, a comparison is made between the existing distance and the distance through u i.e., dist[u] + weight(u, v). If smaller, the value for dist[v] is updated.

## ALGORITHM LOGIC

### THE PRINCIPLE OF RELAXATION

Relaxation is defined as updating the shortest distance known to a vertex. If through another vertex, a shorter path to the said vertex is discovered, then update the distance accordingly.

Mathematically, for an edge (u, v):
dist[v] = min(dist[v], dist[u] + weight(u, v))

### Infinity

Let INF be a large number (for instance, 999999), greater than any possible cost of path in the graph. It shall be used in initialization by setting the value of distances.

## SAMPLE OUTPUT

**Source Node:** 0

**Graph Weights:**
(0-1: 4), (0-2: 2), (1-0: 4), (1-2: 1), (1-3: 5), (2-0: 2), (2-1: 1), (2-3: 8), (2-4: 10),
(3-1: 5), (3-2: 8), (3-4: 2), (3-5: 6), (4-2: 10), (4-3: 2), (4-5: 3), (5-3: 6), (5-4: 3)

**Vertex Distance from Source**
0 0
1 3
2 2
3 8
4 10
5 13
