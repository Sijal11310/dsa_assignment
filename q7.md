# <p align="center">DIJKSTRA'S SHORTEST PATH ALGORITHM</p>

## <p align="center">INTRODUCTION</p>

The program implements **Dijkstra’s Algorithm** to solve the Single-Source Shortest Path problem. We need to provide a weighted graph and a starting node to the program manually , the algorithm calculates the shortest distance from that source to all other reachable vertices. It uses a greedy approach.

---

## <p align="center">DATA STRUCTURE USED</p>

The algorithm is implemented using an **Adjacency Matrix** and several auxiliary arrays:

* **Adjacency Matrix (`graph[V][V]`)**: A 2D array where `graph[i][j]` represents the weight of the edge between vertex `i` and `j`. A value of `0` indicates no direct connection.
* **Distance Array (`dist[V]`)**: Stores the current shortest distance from the source to each vertex.
* **Visited Array (`visited[V]`)**: An array used as a boolean (0 for unvisited, 1 for visited) to keep track of vertices included in the shortest path tree.



---

## <p align="center">FUNCTIONS USED</p>

### findMinDistance(int dist[], int visited[])

This function searches for the "closest" vertex that has not yet been visited.
* **How it works**: It iterates through the `dist[]` array and identifies the index of the vertex with the smallest weight , provided that the `visited[]`  for that index is still `0`.
* **Purpose**: This satisfies the greedy property of Dijkstra’s algorithm by ensuring we always traverse the path from the node with the minimum known distance.

---


### dijkstra(int graph[V][V], int src)

This function contains the logic of the shortest path calculation.
* **Initialization**: Every vertex in the `dist[]` array is set to a very large value (Infinity) and all nodes are marked as unvisited. The distance to the source node itself is initialized to `0`.
* **Main Loop**: The function runs $V-1$ times. In each iteration, it selects the minimum distance `u` and marks it as visited.
* **Relaxation**: For every neighbor `v` of node `u`, the function checks if the total weight of the path through `u` (i.e., `dist[u] + weight(u,v)`) is less than the current known distance `dist[v]`. If it is, `dist[v]` is updated with this smaller value.



---

## <p align="center">ALGORITHM LOGIC</p>

### The Relaxation Principle
Relaxation is the process of updating the shortest distance to a node. If we find a "shortcut" through a newly visited node, we update the records. Mathematically, for an edge $(u, v)$:
$$dist[v] = \min(dist[v], dist[u] + weight(u, v))$$



### Implementation Constraints
2.  **Infinity**: A constant `INF` is defined as a large number (999999) that exceeds any possible path sum in the graph.

---

# <p align="center">SAMPLE OUTPUT</p>

**Source Node:** 0  
**Graph Weights:** (0-1: 4), (0-2: 2), (1-0: 4), (1-2: 1), (1-3: 5), (2-0: 2), (2-1: 1), (2-3: 8), (2-4: 10),      (3-1: 5), (3-2: 8), (3-4: 2), (3-5: 6), (4-2: 10), (4-3: 2), (4-5: 3), (5-3: 6), (5-4: 3)

Vertex   Distance from Source
0        0
1        3
2        2
3        8
4        10
5        13