# Graph Traversal method by BFS and DFS 

## Introduction
This program shows us how to implement an **undirected graph** using **adjacency matrix** and how to traverse the graph using **BFS (Breadth First Search)** and **DFS (Depth First Search)**.

The graph traversal is acheived using
- **Queue** for BFS
- **Stack** for DFS

---

### Adjacency Matrix
A 2D array is used to represent the graph.  
If `graph[i][j] == 1`, it means there is an edge between vertex `i` and vertex `j` and if it is 0 then the edge doesn't exist.

### Stack
Stack is used to implement DFS traversal.

### Queue
Queue is used to implement BFS traversal.

---

## Functions Used

### `void enqueue(struct queue *q, int val)`
Adds an element at the rear of the queue.

### `int dequeue(struct queue *q)`
Removes an element from the front of the queue and returns it.

### `void push(struct stack *s, int val)`
Adds an element on top of the stack.

### `int pop(struct stack *s)`
Removes an element from the top of the stack and returns it.

### `void bfs(int graph[MAX][MAX], int vertices, int start)`
Performs BFS traversal on the graph starting from vertex `start`.

**Working:**
1. Start with the `start` vertex.
2. Mark it as visited.
3. Enqueue it.
4. While queue is not empty:
   - Dequeue a vertex `v`.
   - Print `v`.
   - Visit all the unvisited adjacent vertices and mark them visited and finally enqueue them/

### `void dfs(int graph[MAX][MAX], int vertices, int start)`
Performs DFS traversal on the graph starting from vertex `start`.

**Working:**
1. Start with the `start` vertex.
2. Push it onto stack.
3. While stack is not empty:
   - Pop a vertex `v`.
   - If not visited, print `v` and mark visited.
   - Push all its unvisited adjacent vertices.

---

## Output

### BFS Traversal
0   1   2   3   4

### DFS Traversal
0   1   3   4   2
